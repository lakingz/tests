{
    "collab_server" : "",
    "contents" : "#' @title Autocorrelation Function for Causaly ARMA(p,q) Process\n#'\n#' @description The function acf_arma() computes estimates of the autocorrelation/autocoveriance up to given lag.\n#' @description It returns a data frame including lags, autocovariances and autocorellations.\n#'\n#' @param phi A vector, containing coefficient of AR part as array. it require to have 1 as leading coefficient.\n#' @param theta A vector, containing coefficient of MA part as array. it require to have 1 as leading coefficient.\n#' @param lag The desired maximun lag , The default value is 20.\n#' @param dig The desired rounding digit of return value, the default value is 5\n#'\n#' @return lag       (lag)\n#' @return gamma     (autocovariance)\n#' @return rho       (autocorrelation)\n#'\n#' @note If an integer (within 8 decimal places) is not entered for the value of dig,\n#'   then the floor of dig will be used instead.\n#' @note If an positive integer (within 8 decimal places) is not entered for the value of lag,\n#'   then the floor of absolute value of lag will be used instead.\n#' @note This function STRONGLY REQUIRE arma process to be causal.\n#'\n#' @author Ankai Liu, \\email{ankailiu@trentu.ca}\n#' @references Brockwell, P. J., & Davis, R. A. (2013). Time series: theory and methods. New York, NY: Springer.\n#' @seealso None\n#' @keywords Autocovariance, Autocorrelation, ACF, ARMA\n#'\n#' @examples\n#' # Define time series data in a vector, x\n#' phi <- c(1, -1, 1 / 4)\n#' theta <- c(1, 1)\n#'\n#' # Use acf_arma function\n#' acf_arma(phi, theta)\n#' acf_arma(phi, theta, 20, 8)\n#'\n#' # Another example\n#' phi <- c(1, rnorm(100))\n#' theta <- c(1,rnorm(50))\n#'\n#' acf_arma(phi, theta)\n#' acf_arma(phi, theta, 10, 8)\n#'\n#' @export\n#' @importFrom grDevices rgb2hsv\n#' @importFrom graphics par plot rect text\n#'\n\n\n#\n# since method #1 is not acceptable for computation. we thus use method #2\n# the two inputs would be both strings with the coefficient.\n# the output would be just a string with lag=c(0:20)\n#\n\nacf_arma <- function( phi, theta, lag = 20, dig = 5 ) {\n\n  stopifnot(is.numeric( phi ), is.numeric( theta ),\n            is.vector( phi ), is.vector( theta ),\n            length( phi ) > 0, length( theta ) > 0,\n            is.numeric(lag),\n            is.numeric(dig), dig >= 1)\n\n  if (round(lag) != abs(lag)) {\n    lag <- ceiling(abs(lag))\n  }\n  if (round(dig) != dig) {\n    dig <- ceiling(dig)\n  }\n  if (phi[1] != 1) {\n    stop( \"Leading coefficient of PHI must be 1.\")\n  }\n  if (theta[1] != 1) {\n    stop( \"Leading coefficient of THETA must be 1.\")\n  }\n\n  #\n  # make sure it is casual\n  #\n  #k <- abs(polyroot(phi)) <= 1\n  #if (sum(k) != 0) {\n  #  warning( \"Non casual ARMA, implementation might not be valid\")\n  #}\n  #\n\n  #\n  # we first find psi=theta/phi\n  #\n  p <- length( phi )\n  q <- length( theta )\n\n  phi_1 <- c( phi, rep(0, max(q , lag) * 2) )\n  theta_1 <- c( theta, rep(0,max(q , lag) * 2) )\n  psi <- rep(0, max(q , lag))\n  psi[1] <- theta_1[1]\n  for (i in 2:max(q , lag)) {\n    psi[i] <- theta_1[i] - sum(psi[1:(i - 1)] * phi_1[i:2])\n    # here becaues the phi here is the actual coefficient\n    # (include the negative sign in front of it.)\n    # so we use \"-\" istead \"+)\n  }\n  #print(psi)\n  #print(length(psi))\n\n  #\n  # method 2 find lag 1:p\n  #\n\n  #\n  # Left hand side\n  #\n  phi_2 <- c(rep(0,p),phi,rep(0,2 * p))\n  l <- matrix(c(phi_2[(p + 1):(2 * p)],rep(0,(p)^2 - p)),nrow=p,ncol=p,byrow=FALSE)\n  for (i in 1:p) {\n    for (j in 2:p) {\n      l[i,j] <- phi_2[p + i - (j - 1)]+phi_2[p + i + (j - 1)]\n      #print(phi_2[p - 1 + i - (j - 1)])\n      #print(phi_2[p - 1 + i + (j - 1)])\n    }\n  }\n  #print(l)\n\n  #\n  # right hand side\n  #\n  r <- rep(0,p)\n  for (i in 1:p) {\n    #\n    # we only need right hand side up to p. and we make the rest 0\n    #\n    if ( i <= q ) {\n      r[i] <- sum(psi[1:(q - i + 1)] * theta[i:q])\n      #print(psi[1:(q - i + 1)])\n    }\n    else {\n      r[i] <- 0\n    }\n  }\n  #print(r)\n  gam <- solve(l,r)\n\n  #\n  # method 3, we use existence gamma to find the rest\n  #\n  if ( (p - 1 ) < lag ) {\n    for (i in (p + 1):(lag + 1)) {\n      g <- - sum(phi[-1] * gam[(i - 1):(i - p + 1)])\n      gam <- c(gam, g)\n    }\n  }\n  #print(gam)\n  #\n  # output\n  #\n  rho <- gam / gam[1]\n  data <- round(data.frame(lags = 0:lag, gamma=gam[1:(lag + 1)], rho=rho[1:(lag + 1)]), digit = dig)\n  output <- list(\"data\" = data)\n  return(output)\n}\n#acf_arma(phi, theta, 20, 10)\n\n#\n# test acf\n#\n# phi <- c(1, -1, 1 / 4)\n# theta <- c(1, 1)\n\n# phi <- c(1, rnorm(10))\n# theta <- c(1,rnorm(50))\n\n# closed form formular from book in p93\n# testgamma <- rep(0, 21)\n# for (i in 1:21) {\n#   testgamma[i] <- (32 / 3 + 8 * (i - 1)) * 2^(- i + 1)\n# }\n# testrho <- testgamma / testgamma[1]\n# test1 <- data.frame(lag=0:20, gamma=testgamma,rho=testrho)\n# test1\n\n# test2 <- acf_arma(phi, theta, 20, 10)\n# test1-test2$data\n\n",
    "created" : 1498095136096.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2076900682",
    "id" : "82BCD01D",
    "lastKnownWriteTime" : 1498095143,
    "last_content_update" : 1498095143731,
    "path" : "C:/Users/ankai/Desktop/important saves/time series/time_series_2017/code_staging/acf_arma_ankai.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}